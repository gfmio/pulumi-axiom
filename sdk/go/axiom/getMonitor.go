// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package axiom

import (
	"context"
	"reflect"

	"github.com/gfmio/pulumi-axiom/sdk/go/axiom/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

func LookupMonitor(ctx *pulumi.Context, args *LookupMonitorArgs, opts ...pulumi.InvokeOption) (*LookupMonitorResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupMonitorResult
	err := ctx.Invoke("axiom:index/getMonitor:getMonitor", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking getMonitor.
type LookupMonitorArgs struct {
	// Monitor identifier
	Id string `pulumi:"id"`
}

// A collection of values returned by getMonitor.
type LookupMonitorResult struct {
	// If the monitor should trigger an alert if there is no data
	AlertOnNoData bool `pulumi:"alertOnNoData"`
	// The query used inside the monitor
	AplQuery string `pulumi:"aplQuery"`
	// Monitor description
	Description string `pulumi:"description"`
	// The time the monitor will be disabled until
	DisabledUntil string `pulumi:"disabledUntil"`
	// Monitor identifier
	Id string `pulumi:"id"`
	// How often the monitor should run
	IntervalMinutes int `pulumi:"intervalMinutes"`
	// Monitor name
	Name string `pulumi:"name"`
	// A list of notifier id's to be used when this monitor triggers
	NotifierIds   []string `pulumi:"notifierIds"`
	NotifyByGroup bool     `pulumi:"notifyByGroup"`
	// Operator used in monitor trigger evaluation
	Operator string `pulumi:"operator"`
	// Query time range from now
	RangeMinutes int  `pulumi:"rangeMinutes"`
	Resolvable   bool `pulumi:"resolvable"`
	// The threshold where the monitor should trigger
	Threshold float64 `pulumi:"threshold"`
}

func LookupMonitorOutput(ctx *pulumi.Context, args LookupMonitorOutputArgs, opts ...pulumi.InvokeOption) LookupMonitorResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupMonitorResult, error) {
			args := v.(LookupMonitorArgs)
			r, err := LookupMonitor(ctx, &args, opts...)
			var s LookupMonitorResult
			if r != nil {
				s = *r
			}
			return s, err
		}).(LookupMonitorResultOutput)
}

// A collection of arguments for invoking getMonitor.
type LookupMonitorOutputArgs struct {
	// Monitor identifier
	Id pulumi.StringInput `pulumi:"id"`
}

func (LookupMonitorOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupMonitorArgs)(nil)).Elem()
}

// A collection of values returned by getMonitor.
type LookupMonitorResultOutput struct{ *pulumi.OutputState }

func (LookupMonitorResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupMonitorResult)(nil)).Elem()
}

func (o LookupMonitorResultOutput) ToLookupMonitorResultOutput() LookupMonitorResultOutput {
	return o
}

func (o LookupMonitorResultOutput) ToLookupMonitorResultOutputWithContext(ctx context.Context) LookupMonitorResultOutput {
	return o
}

// If the monitor should trigger an alert if there is no data
func (o LookupMonitorResultOutput) AlertOnNoData() pulumi.BoolOutput {
	return o.ApplyT(func(v LookupMonitorResult) bool { return v.AlertOnNoData }).(pulumi.BoolOutput)
}

// The query used inside the monitor
func (o LookupMonitorResultOutput) AplQuery() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMonitorResult) string { return v.AplQuery }).(pulumi.StringOutput)
}

// Monitor description
func (o LookupMonitorResultOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMonitorResult) string { return v.Description }).(pulumi.StringOutput)
}

// The time the monitor will be disabled until
func (o LookupMonitorResultOutput) DisabledUntil() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMonitorResult) string { return v.DisabledUntil }).(pulumi.StringOutput)
}

// Monitor identifier
func (o LookupMonitorResultOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMonitorResult) string { return v.Id }).(pulumi.StringOutput)
}

// How often the monitor should run
func (o LookupMonitorResultOutput) IntervalMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v LookupMonitorResult) int { return v.IntervalMinutes }).(pulumi.IntOutput)
}

// Monitor name
func (o LookupMonitorResultOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMonitorResult) string { return v.Name }).(pulumi.StringOutput)
}

// A list of notifier id's to be used when this monitor triggers
func (o LookupMonitorResultOutput) NotifierIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v LookupMonitorResult) []string { return v.NotifierIds }).(pulumi.StringArrayOutput)
}

func (o LookupMonitorResultOutput) NotifyByGroup() pulumi.BoolOutput {
	return o.ApplyT(func(v LookupMonitorResult) bool { return v.NotifyByGroup }).(pulumi.BoolOutput)
}

// Operator used in monitor trigger evaluation
func (o LookupMonitorResultOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v LookupMonitorResult) string { return v.Operator }).(pulumi.StringOutput)
}

// Query time range from now
func (o LookupMonitorResultOutput) RangeMinutes() pulumi.IntOutput {
	return o.ApplyT(func(v LookupMonitorResult) int { return v.RangeMinutes }).(pulumi.IntOutput)
}

func (o LookupMonitorResultOutput) Resolvable() pulumi.BoolOutput {
	return o.ApplyT(func(v LookupMonitorResult) bool { return v.Resolvable }).(pulumi.BoolOutput)
}

// The threshold where the monitor should trigger
func (o LookupMonitorResultOutput) Threshold() pulumi.Float64Output {
	return o.ApplyT(func(v LookupMonitorResult) float64 { return v.Threshold }).(pulumi.Float64Output)
}

func init() {
	pulumi.RegisterOutputType(LookupMonitorResultOutput{})
}
